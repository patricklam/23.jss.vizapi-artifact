\section{Design Decisions}
\label{sec:design-decisions}

Having described VizAPI's implementation, we now broaden our attention
and discuss possible design alternatives, particularly in terms of toolkits
that we could have used.

As mentioned in Section~\ref{sec:implementation}, VizAPI presents both
static and dynamic information. Static analysis will typically present
over-approximations (e.g. both branches of a conditional might be
taken), except for under-approximations in special cases like
reflection and ``eval''. VizAPI makes almost maximally coarse
over-approximations, for instance by using Class Hierarchy Analysis to
approximate method calls. The soundiness
manifesto~\cite{livshits15:_in_defen_sound} discusses the
underapproximations used by typical static analysis in more detail.

On the other hand, dynamic analysis under-approximates possible
program behaviours: it reports only the behaviour that is induced by
a particular program input. 

\subsection{Static analysis}
We describe potential static analysis approaches, from low-level
bytecode manipulation through to declaratively declaring desired
analysis facts.

At the intraprocedural level, most tools provide access to bytecode
manipulation. Some tools allow users to supply Java code which is
then compiled into bytecode. Soot has an intermediate three-address code.

Working at the bytecode level imposes unnecessary complexity on
static analyses. See early Soot papers for details.

Javassist, BCEL, ASM

cglib

ByteBuddy


DiSL https://link.springer.com/chapter/10.1007/978-3-642-35182-2_18

https://stackoverflow.com/questions/9167436/dynamic-java-bytecode-manipulation-framework-comparison



SCAM21 submission on mocks


Drivers

\paragraph{Pointer analysis and callgraphs.}

Pointer analysis: haven't we solved this problem already? (Hind, 20 years ago).

CHA: simplest possible option

RTA

Demand-driven approaches

Object-sensitive

Soundiness

\paragraph{Going interprocedural}
Assuming that we have a call graph available, the next challenge in
designing a tool is to correctly propagate data interprocedurally.
Even with Soot's call graph informatoin, it is still not that easy to
do whole-program analyses: it is up to the user to manually propagate
information at method invocation sites.

Heros implements IFDS/IDE for interprocedural analysis.
It's more complicated to use than intraprocedural analysis.

As an alternative to Heros, Doop enables its users to state
declarative facts. It then uses solvers to compute the solution over the
entire program. The pointer analysis to be used is a parameter.

Runtime of Soot versus Doop and Heros.


\subsection{Dynamic analysis}

java agent versus JVMTI

Code rewriting

