\section{Design Decisions}
\label{sec:design-decisions}

Having described VizAPI's implementation, we now broaden our attention
and discuss possible design alternatives, particularly in terms of toolkits
that we could have used.

As mentioned in Section~\ref{sec:implementation}, VizAPI presents both
static and dynamic information. Static analysis will typically present
over-approximations (e.g. both branches of a conditional might be
taken), except for under-approximations in special cases like
reflection and ``eval''. VizAPI makes almost maximally coarse
over-approximations, for instance by using Class Hierarchy Analysis to
approximate method calls. The soundiness
manifesto~\cite{livshits15:_in_defen_sound} discusses the
underapproximations used by typical static analysis in more detail.

On the other hand, dynamic analysis under-approximates possible
program behaviours: it reports only the behaviour that is induced by
a particular program input. It completely reports that behaviour, though,
and sees through constructs that are difficult for static analyses to
handle soundly. TamiFlex~\cite{bodden11:_tamin_reflec} dynamically captures
information about, for instance, which classes are loaded at runtime,
and feeds that back to the static analysis.

VizAPI integrates static and dynamic information. The approach is still not
sound with respect to all potential executions, and it does not integrate
dynamic class loading information into the static results, but it does
make both types of information visible to the user.

\subsection{Static analysis}
We next describe potential static analysis and transformation
approaches, from low-level bytecode manipulation through to
declaratively declaring desired analysis facts. VizAPI extracts static
facts from the programs under analysis. VizAPI also carries out some
program transformation so that it can collect dynamic facts.

Java bytecode is commonly used by program analysis tools as an input format,
since it preserves the semantics of the original source code and, unless
obfuscated, contains source-level entities such as classes and methods,
with their original names.

Although source-level information information is present, it can be
difficult to extract. Local variable names and original code structure
may not be present; the code structure can be recovered and local
variable names could be inferred using Big Code techniques similar to
those used in JavaScript by Raychev et al~\cite{raychev2016learning}.

Bytecode tools provide varying levels of abstraction. We discuss three
bytecode-level tools here.

The Apache Commons Byte Code Engineering Library\footnote{\url{https://commons.apache.org/proper/commons-bcel/}} (BCEL) is a low-level library that
provides a very thin abstraction layer to its user. In particular,
it requires users to manually manage constant pool entries and provides
verbatim access to stack-based bytecode instructions.

The ASM library\footnote{\url{https://asm.ow2.io/}} provides many of
the same capabilities as BCEL, but also a somewhat more robust
abstraction layer which, for instance, manages the constant pool
itself. In addition to an object-oriented (``tree-based'') API like
that of BCEL, it also provides an event-based API which trades increased
performance for decreased flexibility for the user (they must write
the analysis code in a certain way).

% next two paragraphs are still rough
We chose to use Javassist~\cite{chiba00:_load_struc_reflec_java}
for VizAPI. It provides more of an abstraction layer than BCEL (no
constant pool) but less than ASM (only one API, not two). For our purposes,
any of the libraries would have worked. (?)

The Soot framework~\cite{lam11:_soot_java} provides more support for
sophisticated intraprocedural analyses: instead of having to work with
stack-based bytecode, it provides a three-address code with explicit
arguments for instructions. Soot can also support program transformation.
Javassist makes it easier to write code, as long as it's the kind of
code that you want. ASM requires you to write bytecode. ByteBuddy supports
generating method bodies by declaring their contents, to some extent.

\paragraph{Run-time code changes.}



Soot has an intermediate three-address code.
Some tools allow users to supply Java code which is
then compiled into bytecode. 


ByteBuddy

Javassist, BCEL, ASM

cglib

ByteBuddy


DiSL https://link.springer.com/chapter/10.1007/978-3-642-35182-2_18

https://stackoverflow.com/questions/9167436/dynamic-java-bytecode-manipulation-framework-comparison



SCAM21 submission on mocks


Drivers

\paragraph{Pointer analysis and callgraphs.}

Pointer analysis: haven't we solved this problem already? (Hind, 20 years ago).

CHA: simplest possible option

RTA

Demand-driven approaches

Object-sensitive

Soundiness

\paragraph{Going interprocedural}
Assuming that we have a call graph available, the next challenge in
designing a tool is to correctly propagate data interprocedurally.
Even with Soot's call graph informatoin, it is still not that easy to
do whole-program analyses: it is up to the user to manually propagate
information at method invocation sites.

Heros implements IFDS/IDE for interprocedural analysis.
It's more complicated to use than intraprocedural analysis.

As an alternative to Heros, Doop enables its users to state
declarative facts. It then uses solvers to compute the solution over the
entire program. The pointer analysis to be used is a parameter.

Runtime of Soot versus Doop and Heros.


\subsection{Dynamic analysis}

java agent versus JVMTI

Code rewriting

